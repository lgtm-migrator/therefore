import { FileDefinition, TypescriptReference } from './definition'
import { toTypescriptDefinition } from './typescript'
import { toJsonSchema } from './schema'
import { renderTemplate } from './template'
import { isDefined } from './util'
import {
    ArrayType,
    DictType,
    IntersectionType,
    isShorthand,
    ObjectType,
    RefType,
    ThereforeTypes,
    TupleType,
    UnionType,
} from './types/composite'
import { schema } from './therefore'
import { EnumType } from './types/enum'

import decamelize from 'decamelize'
import execa from 'execa'
import fastGlob from 'fast-glob'

import path from 'path'
import fs from 'fs'

// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-unsafe-assignment
const { version, name: packageName } = require('../package.json')
const generatedBy = `Generated by ${packageName as string}`

export function isEnum(obj: ThereforeTypes | { [schema.type]: string }): obj is EnumType {
    return obj[schema.type] === 'enum'
}

export function isObject(obj: ThereforeTypes | { [schema.type]: string }): obj is ObjectType {
    return obj[schema.type] === 'object'
}

export function isDict(obj: ThereforeTypes | { [schema.type]: string }): obj is DictType {
    return obj[schema.type] === 'dict'
}

export function isArray(obj: ThereforeTypes | { [schema.type]: string }): obj is ArrayType {
    return obj[schema.type] === 'array'
}

export function isTuple(obj: ThereforeTypes | { [schema.type]: string }): obj is TupleType {
    return obj[schema.type] === 'tuple'
}

export function isRef(obj: ThereforeTypes | { [schema.type]: string }): obj is RefType {
    return obj[schema.type] === '$ref'
}

export function isUnion(obj: ThereforeTypes | { [schema.type]: string }): obj is UnionType {
    return obj[schema.type] === 'union'
}

export function isIntersection(obj: ThereforeTypes | { [schema.type]: string }): obj is IntersectionType {
    return obj[schema.type] === 'intersection'
}

export function isExportable(
    obj: unknown | ThereforeTypes
): obj is TupleType | DictType | ObjectType | EnumType | UnionType | IntersectionType {
    return isShorthand(obj) //&&(isTuple(obj) || isDict(obj) || isObject(obj) || isEnum(obj) || isRef(obj) || isUnion(obj) || isIntersection(obj))
}

export function getSchemaFilename(file: string, extension: string): string {
    return `${file.replace('.ts', '')}${extension}`
}

export function requireReference(
    definitions: Record<string, FileDefinition>,
    current: FileDefinition,
    ref: TypescriptReference
): { file: string; type: string; uuid: string; reference: string } {
    const found = Object.values(definitions)
        .map((d) =>
            d.symbols.map((s) => ({
                uuid: s.tsDefinition.uuid,
                interfaceName: s.tsDefinition.interfaceName,
                referenceName: s.tsDefinition.referenceName,
                file: d.file,
            }))
        )
        .flat()
        .find((s) => s.uuid === ref.uuid)

    if (!found) {
        // this is a locally defined variable
        const tsDefinition = toTypescriptDefinition(ref.name, ref.reference, false)
        current.symbols.push({
            name: ref.name,
            tsDefinition: tsDefinition,
        })

        for (const ref of tsDefinition.references) {
            // recurse down to referencing references
            requireReference(definitions, current, ref)
        }

        //return undefined
        //throw Error(`reference ${ref.uuid} was not found`)
        return {
            file: current.file,
            type: tsDefinition.interfaceName,
            reference: tsDefinition.referenceName,
            uuid: ref.uuid,
        }
    }
    return {
        file: found.file,
        type: found.interfaceName,
        reference: found.referenceName,
        uuid: ref.uuid,
    }
}
// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
const requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require
export function scanModule(entry: string, definitions: { [k: string]: FileDefinition }, fullPath: string): void {
    const definition: FileDefinition = {
        file: fullPath,
        jsonFiles: [],
        symbols: [],
        dependencies: {},
    }
    const relative = path.relative(__dirname, entry).replace(/\\/g, '/').replace('.ts', '')
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
    const module = requireFunc(relative.startsWith('.') ? relative : `./${relative}`)
    for (const [name, symbol] of Object.entries(module)) {
        if (isExportable(symbol)) {
            const schemaName = decamelize(name, '-')
            const schemaFile = `./schemas/${schemaName}.schema.json`
            const schema = toJsonSchema(symbol)

            const tsDefinition = toTypescriptDefinition(name, symbol)
            definition.symbols.push({
                name, // root: path.dirname(entry),
                //schema,
                tsDefinition: tsDefinition,
                schemaFile,
            })

            if (tsDefinition.meta !== undefined) {
                const file = path.join(path.dirname(entry), schemaFile)
                definition.jsonFiles.push({ file, schema: JSON.stringify(schema.schema, null, 2) })
            }

            console.log(` - found ${tsDefinition.interfaceName}`)
        }
        if (definition.symbols.length) {
            definitions[fullPath] = definition
        }
    }
}

export function scanFiles(files: string[], basePath: string): { [k: string]: FileDefinition } {
    const definitions: {
        [k: string]: FileDefinition
    } = {}
    for (const entry of files) {
        const fullPath = path.resolve(basePath, entry)
        let isGenerated = false
        const strippedPath = fullPath.substr(0, fullPath.lastIndexOf('.'))
        for (const ext of ['.ts', '.js']) {
            const p = `${strippedPath}${ext}`
            isGenerated ||= fs.existsSync(p) && fs.readFileSync(p).includes(generatedBy)
        }
        if (isGenerated) {
            console.debug(`scanning ${entry}`)
            console.debug(` * skipping generated schema`)
            continue
        }

        console.log(`scanning ${entry}`)

        try {
            scanModule(entry, definitions, fullPath)
        } catch (e) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            console.debug(e.message, e.stack)
            throw e
        }
    }
    return definitions
}

// eslint-disable-next-line @typescript-eslint/require-await
export async function compileSchemas(
    entries: string[],
    extension: string,
    cwd: string
): Promise<{ file: string; template: string; data: Record<string, string>; type: 'typescript' | 'jsonschema' }[]> {
    const schemaFiles: { file: string; template: string; data: Record<string, string>; type: 'typescript' | 'jsonschema' }[] = []
    const definitions = scanFiles(entries, cwd)

    // const localReferences: Record<string, string> = Object.fromEntries(
    //     Object.values(definitions)
    //         .map((d) => d.symbols.map((s) => s.tsDefinition.references.map((r) => [r.uuid, r.referenceName])))
    //         .flat(2)
    // ) as Record<string, string>
    const localReferences = {}

    for (const [file, definition] of Object.entries(definitions)) {
        const required = definition.symbols
            .map((i) => i.tsDefinition.references.map((r) => requireReference(definitions, definition, r)))
            .flat()
        //.filter(isDefined)

        for (const r of required) {
            definition.dependencies[r.file] ??= []
            definition.dependencies[r.file]?.push(r.type)
        }

        const schemaFileName = getSchemaFilename(file, extension)

        const relativeDependencies = Object.entries(definition.dependencies)
            .map(([f, deps]) => ({
                file: getSchemaFilename(f, extension),
                deps: `{ ${[...new Set(deps)].sort().join(', ')} }`,
            }))
            .filter(({ file }) => file !== schemaFileName)
            .map(({ file, deps }) => {
                const otherPath = path.relative(path.dirname(schemaFileName), file).replace('.ts', '').replace(/\\/g, '/')
                return `import ${deps} from '${otherPath.startsWith('.') ? otherPath : `./${otherPath}`}'`
            })

        const references = Object.fromEntries(required.map((r) => [r.uuid, r.reference] as [string, string]))
        schemaFiles.push(
            {
                file: schemaFileName,
                type: 'typescript',
                template: ([] as string[])
                    .concat(
                        ['/**', ` * ${generatedBy}@v${version as string}`, ' * Do not manually touch this', ' */\n'],
                        ['/* eslint-disable */'],
                        definition.symbols
                            .filter((i) => i.tsDefinition?.meta !== undefined && i.schemaFile)
                            .map((i) => `import ${i.name}Schema from '${i.schemaFile!}'`)
                            .sort(),
                        relativeDependencies.length ? ['', ...relativeDependencies] : [],
                        ['', `import AjvValidator from 'ajv'`, ''],
                        Object.values(definition.symbols)
                            .map((i) => [
                                i.tsDefinition.declaration,
                                i.tsDefinition.meta !== undefined
                                    ? renderTemplate(i.tsDefinition.meta, {
                                          schema: `${i.name}Schema`,
                                      })
                                    : undefined,
                            ])
                            .flat(2)
                            .filter(isDefined)
                    )
                    .join('\n'),
                data: { ...localReferences, ...references },
            },
            ...definition.jsonFiles.map((j) => ({
                file: j.file,
                type: 'jsonschema' as const,
                template: j.schema,
                data: { ...localReferences, ...references },
            }))
        )
    }

    return schemaFiles
}

export async function execute({
    globs,
    excludes,
    format,
    extension,
}: {
    globs: string[]
    excludes: string[]
    format: boolean
    extension: string
}): Promise<void> {
    console.log(globs)
    const entries = await fastGlob([...globs, ...excludes.map((e) => `!${e}`)], { dot: true })

    const schemaFiles = await compileSchemas(entries, extension, process.cwd())

    for (const { file, template, data } of schemaFiles) {
        //fs.writeFileSync(file)
        fs.mkdirSync(path.dirname(file), { recursive: true })
        const references = {}
        console.log(file, references)
        fs.writeFileSync(file, renderTemplate(template, data))

        // for (const { file, schema } of definition.jsonFiles) {
        //     fs.mkdirSync(path.dirname(file), { recursive: true })
        //     console.log(file, references)
        //     fs.writeFileSync(file, template(schema, references))
        // }
    }

    if (schemaFiles.length > 0 && format) {
        execa.commandSync(`yarn prettier --write ${schemaFiles.map((f) => path.relative(process.cwd(), f.file)).join(' ')}`, {
            stdio: 'inherit',
        })
    }
}
